/* Include s3d symbols */
#include <Script3d.h>
//#include <Camera.s3d.h>

/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000;


#define LOOK 1
#define MOVE 2

#define TRANSLATE_MODE 0
#define SCALE_MODE 1 
#define TEXTURE_MODE 2
#define ROTATE_MODE 3
#define NUM_MODES 4

#define LOWPOLYWORLD
#define DEBUG
//#define HIGHPOLY
// TODO: put your global variables here
//#define CAVE

/* Camera globals */
//#ifdef CAVE
var CamPos = [-3, 1.1, 13.0]; 	// camera position


var shapes;
var curShape = 0;
var MAXBOUND = 50;
var dP = 0.000001;
var scaling = false;
var joyMode = MOVE;
var opMode = TRANSLATE_MODE;
var lastButtons = 0;
var worldRotation = 0;
var pointer = [0.5,0.5,0];
var smallShape;
var skyDome;
var furnitureObj;
var furnitureMesh;
var endVert = Vector(3);
var startVert = Vector(3);
var wandRot = [0,0,0];
var b = Array(16);
var kb = Array(16);
var headpos = [1.5,1.8,1.5];

//mode icon
var iconRads = 0;
var iconObj;
var iconTumpleAxis;

/* Light globals */
var skyLights;
var Light1;
var Light2;
var PosL = [0.0, 10.0, 10.0];	// default light position
var groundTexture;

var mSelect;
/* Function declarations */
function CameraMoveMouse();
function getNewKeyboardEvents();
function DrawGrid(col, size);
function joystickMove();
function DrawLine(visible);
function PickShape();
function PositionLights(centre);
function DrawGroundPlane(centre);
function LoadIcon();
function TumpleIcon();

class Shape 
{
	var faces;
	var pos;
	var rot;
	var bounds;
	var corners;
	var yStartpos;
	var pauseCount;
	
	ResetShape();
	SetShape();
	SetShapeFromValues(lt,rt,btm,top,fnt,bk);
	DrawShape();
	CalcBounds(scale);
	CheckBounds();
	FloorBounds();
	CheckValues( bound, lt, olt, ort, bt, tp, obt, otp, ft, bk, oft, obk );
	DistanceToLine(x1, x2);
	Gravity();
	
	GetLeft();
	GetRight();
	GetTop();
	GetBottom();
	GetFront();
	GetBack();
	
	SetLeft(lt);
	SetRight(rt);
	SetBottom(bt);
	setTop(tp);
	SetFront(ft);
	SetBack(bk);
	
	GetPos();
	SetPos(newPos);
};

class MeshShape : Shape
{
	var mesh;
	var tex;
	var obj;
	
	SetMesh(file, normalise);
	DrawShape();
	Clone(oldShape);
};
function MeshShape::SetMesh(file, normalise)
{
	mesh = CVmNewMesh(file);
	obj = CVmObj();
	if(normalise) mesh.Normalize(2);
	
	mesh.CenterBoundingBox();
	var ObjBounds = mesh.GetBoundingBox();
	var newBounds = Vector(3);
	newBounds.x = (ObjBounds[0] + ObjBounds[3]) / 2;
	newBounds.y = (ObjBounds[1] + ObjBounds[4]) / 2;
	newBounds.z = (ObjBounds[2] + ObjBounds[5]) / 2;
	
	Shape::bounds = newBounds;
	
	if (normalise) {
		//cannot manipulate properties of subclass properties directly!
		var oldPos = this.GetPos();
		oldPos.y = 1;	
		this.SetPos(oldPos);
	}
	obj.LinkToMesh(mesh);
}
function Shape::Shape()
{
	faces = {  /* Vertex indices for the 6 faces of a cube. */
	  {0, 1, 2, 3}, {3, 2, 6, 7}, {7, 6, 5, 4},
	  {4, 5, 1, 0}, {5, 6, 2, 1}, {7, 4, 0, 3} };
	 
	pos = [0,20,0];
	rot = [0,0,0];
	bounds = [1,1,1];
	corners = Array(8);
	pauseCount = 0;
	
	for(var i = 0; i < 8; i++)
		corners[i] = Vector(3);
	
	ResetShape();
}
function MeshShape::MeshShape(oldShape)
{
	Shape::pos = oldShape.pos;
	Shape::rot = oldShape.rot;
	Shape::bounds = oldShape.bounds;
	Shape::corners = oldShape.corners;
	Shape::faces = oldShape.faces;
}
function Shape::ResetShape()
{
	bounds = [1,1,1];
	SetShape();
}
function Shape::SetShape() {
	SetShapeFromValues(-bounds.x,bounds.x,-bounds.y,bounds.y,-bounds.z,bounds.z);
}
function Shape::SetShapeFromValues(lt,rt,btm,top,fnt,bk) 
{
	//left face
	corners[0].x = corners[1].x = corners[2].x = corners[3].x = lt;
	
	//right face
	corners[4].x = corners[5].x = corners[6].x = corners[7].x = rt;
	
	//bottom
	corners[0].y = corners[1].y = corners[4].y = corners[5].y = btm;
	
	//top
	corners[2].y = corners[3].y = corners[6].y = corners[7].y = top;
	
	//back - left or right handedness??
	corners[0].z = corners[3].z = corners[4].z = corners[7].z = fnt;
	
	//front
	corners[1].z = corners[2].z = corners[5].z = corners[6].z = bk;
}
function MeshShape::DrawShape()
{
	obj.setPosition(pos);
	obj.setRotation(rot.x, [1,0,0]);
	obj.Rotate(rot.y, [0,1,0]);
	obj.Rotate(rot.z, [0,0,1]);
	obj.SetScale(bounds);
	obj.Draw();
}
function Shape::DrawShape()
{
	//glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	//glDisable(GL_LIGHTING);
	//glLoadIdentity();
	
	glPushMatrix();
	glTranslate(pos);
	glBegin(GL_QUADS);
	for(var i = 0; i < 6; i++)
	{
		glVertex(corners[faces[i][0]]);
		glVertex(corners[faces[i][1]]);
		glVertex(corners[faces[i][2]]);
		glVertex(corners[faces[i][3]]);
	}
	glEnd();
	
	glPopMatrix();
	//glPopAttrib();	
}

function Shape::FloorBounds() {
	if(bounds.x < 0.001) bounds.x = 0.001;
	else if(bounds.x > 100) bounds.x = 100;
	
	if(bounds.y < 0.001) bounds.y = 0.001;
	else if(bounds.y > 100) bounds.y = 100;
	
	if(bounds.z < 0.001) bounds.z = 0.001;
	else if(bounds.z > 100) bounds.z = 100;
}
function Shape::CalcBounds(scale) {
	bounds.x = bounds.x * scale.x;
	bounds.y = bounds.y * scale.y;
	bounds.z = bounds.z * scale.z; 
	
	//bounds.x = bounds.x > MAXBOUND ? MAXBOUND : bounds.x;
	//bounds.y = bounds.y > MAXBOUND / 2 ? MAXBOUND / 2: bounds.y;
	//bounds.z = bounds.z > MAXBOUND ? MAXBOUND : bounds.z;
	
	SetShape();
}
function Shape::CheckBounds() {
	//ground plane
	//if(GetBottom() < 0)  pos.y -= pos.y - bounds.y; 
	
	var leftBound = -MAXBOUND;
	var bottomBound = 1;
	var frontBound = -MAXBOUND;
	
	var rightBound = MAXBOUND;
	var topBound = MAXBOUND;
	var backBound = MAXBOUND;

	// 'jiggle it a little' - removes some edge cases
	pos.x += dP;
	pos.y += dP;
	pos.z += dP;
	
	foreach(var s in shapes) {
		if(s == this) continue;
		if(s.GetRight() > leftBound)
			leftBound = CheckValues( leftBound, GetLeft(), s.GetLeft(), s.GetRight(), GetBottom() + 0.15, GetTop() - 0.15, 
								s.GetBottom(), s.GetTop(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetLeft() < rightBound)
			rightBound = -CheckValues( -rightBound, -GetRight(), -s.GetRight(), -s.GetLeft(), GetBottom() + 0.15, GetTop() - 0.15,
								s.GetBottom(), s.GetTop(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetTop() > bottomBound)
			bottomBound = CheckValues( bottomBound, GetBottom(), s.GetBottom(), s.GetTop(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetBottom() < topBound)
			topBound = -CheckValues( -topBound, -GetTop(), -s.GetTop(), -s.GetBottom(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetFront() > frontBound)
			frontBound = CheckValues( frontBound, GetFront(), s.GetFront(), s.GetBack(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetBottom() + 0.15, GetTop() - 0.15, s.GetBottom(), s.GetTop());
		if(s.GetBack() < backBound)
			backBound = -CheckValues( -backBound, -GetBack(), -s.GetBack(), -s.GetFront(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetBottom() + 0.15, GetTop() - 0.15, s.GetBottom(), s.GetTop());					
	}	
	
	// jiggle it back
	pos.x -= dP;
	pos.y -= dP;
	pos.z -= dP;
	
	if(GetLeft() < leftBound && GetRight() > rightBound) {
		bounds.x = (rightBound - leftBound) / 2;
		SetShape();
	} else if(GetLeft() < leftBound) SetLeft(leftBound);
	else if(GetRight() > rightBound) SetRight(rightBound);
	
	
	if(GetBottom() < bottomBound && GetTop() > topBound) {
		bounds.y = (topBound - bottomBound) / 2;
		SetShape();
	} else if(GetBottom() < bottomBound) SetBottom(bottomBound);
	else if(GetTop() > topBound) SetTop(topBound);
	
	if(GetFront() < frontBound && GetBack() > backBound) {
		bounds.z = (backBound - frontBound - 0.15) / 2;
		SetShape();
	} else if(GetFront() < frontBound) SetFront(frontBound);
	else if(GetBack() > backBound) SetBack(backBound);
}
function Shape::CheckValues( bound, lt, olt, ort, bt, tp, obt, otp, ft, bk, oft, obk )
{
	if(	//check if the left face is inside other cube
		olt < lt && ort > lt
		//check if the cubes overlap in the vertical direction: 3 cases
		//bottom of this between top and bottom of other
		&& ((otp > bt && obt < bt)
		//top of this between top and bottom of other
		|| (otp > tp && obt < tp)
		//top and bottom of other inside this
		|| (otp < tp && obt > bt))
		//the same 3 cases for front and back
		&& ((oft < ft && obk > ft) || (oft < bk && obk > bk) || (obk < bk && oft > ft))) 	
			bound = ort;

	return bound;
}
function Shape::Gravity()
{
	static var dS = 0;
	//if(pauseCount > 0) pauseCount--;
	//if ((b[5] == 1 && shapes[curShape] == this) || pauseCount > 0) return;
	
	//switch this off and watch them wobble!
	pos.y -= 0.1;
	var bottomBound = 0;
	foreach(var s in shapes) {
			bottomBound = CheckValues( bottomBound, GetBottom(), s.GetBottom(), s.GetTop(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
	}
	pos.y += 0.1;
	
	//v = sqrt(2a * delta S)
	if(dS == 0) dS = 0.1;
	
	var oldY = pos.y;
	pos.y -= sqrt(2*dS);
	if(GetBottom() < bottomBound)  SetBottom(bottomBound);
	
	dS = oldY - pos.y;
}
function Shape::SetLeft(lt) {
	pos.x = lt + bounds.x;
}
function Shape::SetRight(rt) {
	pos.x = rt - bounds.x;
}
function Shape::SetBottom(bt) {
	pos.y = bt + bounds.y;
}
function Shape::SetTop(tp) {
	pos.y = tp - bounds.y;
}
function Shape::SetFront(bt) {
	pos.z = bt + bounds.z;
}
function Shape::SetBack(tp) {
	pos.z = tp - bounds.z;
}
function Shape::GetLeft() {
	return pos.x - bounds.x;
}
function Shape::GetRight() {
	return pos.x + bounds.x;
}
function Shape::GetBottom() {
	return pos.y - bounds.y;
}
function Shape::GetTop() {
	return pos.y + bounds.y;
}
function Shape::GetFront() {
	return pos.z - bounds.z;
}
function Shape::GetBack() {
	return pos.z + bounds.z;
}
function Shape::GetPos() {
	return pos;
}
function Shape::SetPos(newPos) {
	pos = newPos;
}
function Shape::DistanceToLine(x1, x2) {
//http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
	return modulus((pos - x1) ^ (pos - x2)) / modulus(x2 - x1);
}

class MeshSelector {
	var meshes;
	var fileNames;
	var rot;
	var visible;
	var selected;
	var preVisible;
	
	Draw();
};

function MeshSelector::MeshSelector() {
	rot = 0;
	visible = false;
	
	meshes = Array(4);
	fileNames = Array(4);
	
	#ifdef HIGHPOLY
	fileNames[0] = "tree1.aam";
	fileNames[1] = "tree2.aam";
	fileNames[2] = "tree3.aam";
	#else
	fileNames[0] = "monkey.aam";
	fileNames[1] = "sphere.aam";
	fileNames[2] = "cone.aam";
	fileNames[3] = "fountain1.aam";
	//fileNames[3] = "skewedHouse.AAM";
	//fileNames[2] = "Fence.AAM";
	
	#endif

	for(var i = 0; i < len(fileNames); i++) {
		var mesh = CVmNewMesh(fileNames[i]);
		#ifdef CAVE
		mesh.Normalize(0.1);
		#else
		mesh.Normalize(0.5);
		#endif
		mesh.CenterBoundingBox();
		meshes[i] = CVmObj();
		meshes[i].LinkToMesh(mesh);
	}
}
function MeshSelector::Draw() {
	
	#ifdef CAVE
	var centre = CameraGetPosition() + headpos;
	#else
	var centre = CameraGetPosition(); // + headpos;
	#endif
	
	var d = 3;
	var selectedMesh = -1;
	var rads = rot;
	#ifdef CAVE
	var r = 0.35;
	#else
	var r = 2;
	#endif
	for (var i = 0; i < len(meshes); i++) {
		meshes[i].SetPosition(centre.x + r * sin(rads), centre.y, centre.z - r * cos(rads));
		if (Abs(rads) < d) { //checks to see if this shape is selected
			selectedMesh = i;
		 	d = Abs(rads);
		}
		meshes[i].draw();
		
		
		ConsoleText(0.1,0.03*i+0.03,Sprintf("i: %i, rads: %f, d: %f, selectedMesh: %i", i, rads, d, selectedMesh));
		rads += 0.4; //distance between shapes
	}
	if (selectedMesh > -1) {
		glColor(.26,.71,.90);
		meshes[selectedMesh].DrawBoundingBox();
		selected = selectedMesh;
	} else selected = 0;
}
function OnDownload()
{
	// TODO: download your resources here
	//#ifdef CAVE
	//FileDownload("sceneData.zip");
	//FileDownload("shapes.zip");
	//#endif
}



function OnInit(params)
{
	setLocalDir();
	SceneSetParam(VR_HEADTRACKER,1);
	/* initialize camera */
	CameraSetPosition(CamPos);
		
	shapes = Array(2);
	
	glEnable(GL_NORMALIZE);
	
	shapes[0] = Shape();
	shapes[0].pos = [0,1,2.5];
	shapes[1] = Shape();
	shapes[1].pos = [0,1,0];
	
	//smallShape = Shape();
	smallShape = MeshShape();
	smallShape.SetMesh("pointer.aam", false);
	smallShape.pos = startVert = [0,1,0];
	smallShape.CalcBounds([0.1,0.1,0.1]);
	
	var mesh = CVmNewMesh("skyDome.aam");
	skyDome = CVmObj();
	skyDome.LinkToMesh(mesh);
	skyDome.SetScale([100,100,100]);
	skyDome.SetPosition(camPos.x0z);
	
	/* initialize light */
	skyLights = Array(6);
	for(var i = 0; i < 6; i++) {
		skyLights[i] = CVmLight();
		skyLights[i].SetDiffuse(.5, .5, .5);
		skyLights[i].Enable();
	}
	PositionLights(camPos.x0z);
	groundTexture = CVmTexture("ground.jpg");
	
	
	Light1 = CVmLight();
	//Light1.SetPosition(PosL);
	Light1.SetAmbient(1, 1, 1);
	Light1.Enable();	

	//Light2 = CVmLight();
	//Light2.SetPosition([0,10,-2]);
	//Light2.SetDiffuse(1, 0, 0);
	//Light2.Enable();
	
	for (var i = 0; i < 16; i++) kb[i] = b[i] = 0;
	
	//#ifndef CAVE
	SetLocalDir("\\shapes\\");
	//#endif
	mSelect = MeshSelector();
	//#ifndef CAVE
	SetLocalDir();
	//#endif
	
	var iconMesh = CVmNewMesh("icons\\translate.aam");
	iconMesh.Normalize(0.05);
	iconObj  = CVmObj();
    iconObj.LinkToMesh(iconMesh);
    TumpleIcon();
	//iconObj
}

function PositionLights(centre)
{
	for(var i = 0; i < 6; i++)
		skyLights[i].SetPosition(centre.x + 80 * sin(i*1.047), 30, centre.z - 80 * cos(i*1.047));
}
function DrawGroundPlane(centre)
{
	glPushMatrix();
	glColor(GL_RED);
	
	SetActiveTexture(groundTexture);
	glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
	// when texture area is small, bilinear filter the closest mipmap
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
                 GL_LINEAR_MIPMAP_NEAREST );
	// when texture area is large, bilinear filter the original
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

	// the texture wraps over at the edges (repeat)
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
	
	glTranslate(centre);
	glBegin(GL_QUADS);
	glTexCoord(200.0+centre.x,centre.z); glVertex(100,0,-100);
	glTexCoord(centre.x,centre.z); glVertex(-100,0,-100);
	glTexCoord(centre.x,200.0+centre.z); glVertex(-100,0,100);
	glTexCoord(200.0+centre.x,200.0+centre.z); glVertex(100,0,100);
	glEnd();
	glTranslate(-centre);
	
	glColor(1,1,1);
	glPopMatrix();
	
}
function OnFrame()
{
 	joystickMove();
	
	/* manage camera */
	CameraMoveMouse();
	
	SceneBegin();
	SetClearColor(1,1,1);
	//SceneEnableFog(1,100,[0,0,0]);
	glEnable(GL_NORMALIZE);

	smallShape.DrawShape();
	iconObj.SetPosition(smallShape.pos + [0.04 * sin(iconRads),0.05,0.04 * cos(iconRads)]);
	iconObj.Draw();
	if (mSelect.visible) mSelect.Draw();
		
	var CameraPos = CameraGetPosition() + headpos;
	glTranslate(CameraPos);
	glRotate(worldRotation,0,1,0);
	glTranslate(-CameraPos);
	
	DrawLine(!mSelect.visible); //b[5] == 1);
	if(b[5] == 0) PickShape();
	
	glColor(1,0,0);
	for (var i = 0; i < len(shapes); i++) {
		if(curShape == i) {
			glColor(.26,.71,.90);
			if(shapes[i].__GetName() == "MESHSHAPE") shapes[i].obj.DrawBoundingBox();
		}
		shapes[i].DrawShape();
		if(curShape == i) glColor(1,0,0);
	}
	
	PositionLights(CameraPos.x0z);
	skyDome.SetPosition(CameraPos.x0z);
	
	#ifndef LOWPOLYWORLD
	skyDome.Draw();
	DrawGroundPlane(CameraPos.x0z);
	#else
	DrawGrid([0.5, 0.5, 0.5], 10);
	#endif
	//furnitureObj .Draw();
	SceneEnd();
}

function DrawLine(visible) 
{
	var vec = Vector(3);
	vec.z = -100;
	vec = VectorRotate(wandRot.x,1,0,0,vec,false);
	vec = VectorRotate(wandRot.y - worldRotation,0,1,0,vec,false);
	//vec = VectorRotate(wandRot.z,0,0,1,vec,false);
	
	endVert.x = startVert.x + vec.x;
	endVert.y = startVert.y + vec.y;
	endVert.z = startVert.z + vec.z;
	
	if(!visible) return;
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	
	glEnable (GL_LINE_STIPPLE);
	glLineStipple (1, 0x00FF);
	glBegin(GL_LINES);
		glVertex(startVert);
		glVertex(endVert);
	glEnd();
	glDisable (GL_LINE_STIPPLE);
	
}
function PickShape(){
	curShape = -1;
	var closest = 1000;
	for (var i = 0; i < len(shapes); i++) {
		var dis = shapes[i].DistanceToLine(startVert, endVert);
		if(dis < closest) {
			curShape = i;
			closest = dis;
		}
		#ifdef DEBUG
		ConsoleText(0.1,0.03*i,Sprintf("distance: %.2f - %i", shapes[i].DistanceToLine(smallShape.pos, endVert), curShape));
		#endif
	}
}
function DownloadReady(RequestID)
{
	// TODO
}



function OnTimer()
{
	static var waitCount = 10;
	getNewKeyboardEvents();
	//joystickMove();
	foreach (var shape in shapes) shape.Gravity();
	iconRads += 0.01;
	if(waitCount-- == 0) {
		skyDome.RotateABS(0.005,0,1,0);
		waitCount = 10;
	}
	iconObj.Rotate(0.3,iconTumpleAxis);
}
// Camera manager (using mouse)
function CameraMoveMouse()
{
	static var InMouseR = false, InMouseL = false;				
	static var PrecX = 0, PrecY = 0;			
	// Change these values to modify the mouse sensitivity
	var TR_SENSITIVITY  = 0.0001 ;//* SceneScale;
	var ROT_SENSITIVITY = 0.01;
	// Mouse manager
	if(Mouse.ButtonL && !Mouse.ButtonR)
	{
		//====  Left Button: Camera rotation  ====//
		if (InMouseL)
		{			
			CameraRotate(( Mouse.X-PrecX)*ROT_SENSITIVITY,0,1,0);
			CameraRotateABS((Mouse.Y-PrecY)*ROT_SENSITIVITY,1,0,0);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseL = true;
		InMouseR = false;
	}
	else
	if(Mouse.ButtonR)
	{
	
		//====  Right Button: Camera translation  ====//
		if (InMouseR)
		{
			var CameraMatrix = CameraGetMatrix();
			var CameraPos = CameraGetPosition();
			if (!Mouse.ButtonL) 
			//====  Translation on X and Z axis ====//
				CameraPos += CameraGetZAxis() * (Mouse.y-PrecY)*TR_SENSITIVITY + CameraGetXAxis() * (Mouse.X- PrecX)*TR_SENSITIVITY;
			else
			//====  Right + Left Button: Translation on Y axis ====//
				CameraPos -= CameraGetYAxis() * (Mouse.y-PrecY)*TR_SENSITIVITY;
			
			CameraSetPosition(CameraPos);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseR = true;
		InMouseL = false;
	}	
	else
	{
		InMouseR = false;
		InMouseL = false;
	}
	/*
	var CameraPos = CameraGetPosition();
	var CameraDir = CameraGetDirection();*/
}


function OnExit()
{
	// TODO: put your cleanup code here
}

function joystickMove()
{
	var MV_SENSITIVITY  = 0.2;
	var ROT_SENSITIVITY = 5;
	var DEADZONE  = 0.1;
	
	var buts = GetTrackerButtons(1);
	
	#ifndef CAVE
	var j = CVmJoystick();
	if (j.enabled) {
	buts = j.Buttons;
	#endif
	for (var i=0;i<=15;i+=1)
	{
		if(1==(buts%2) || kb[i]==1) b[i] = 1;
		else b[i] = 0;
		buts/=2;
		//b[i] = 0;
	}
	#ifndef CAVE
	}
	#endif
	
	#ifdef CAVE
	headpos = GetTrackerPos(0);
	var headrot = GetTrackerRot(0);
	var wandpos = GetTrackerPos(1);
	wandrot = GetTrackerRot(1);
	buts = GetTrackerButtons(1);
	#else
	buts = j.Buttons;
	static var preY = 0;
	static var preX = 0;
	headpos = [1.1,1.8,2];
	var headrot = [0,0,0];
	var wandpos = [0.4,-0.1,-1.0];
	if (j.enabled) {
		if (j.u < 0.5 - DEADZONE || j.u > 0.5 + DEADZONE) wandrot.y -= (j.u - 0.5) * 5;
		if (j.r < 0.5 - DEADZONE || j.r > 0.5 + DEADZONE) wandrot.x += (j.r - 0.5) * 5;
	}
	#endif
	var joystick = GetTrackerJoy(1);
	
	var CameraMatrix = CameraGetMatrix();
	var CameraPos = CameraGetPosition();
	
	#ifdef DEBUG
	ConsoleColor(1,1,1,1);
	ConsoleText(0.1,0.15,Sprintf("head pos: %.2f, %.2f, %.2f", headpos.x, headpos.y, headpos.z));
	ConsoleText(0.1,0.18,Sprintf("head rot: %.2f, %.2f, %.2f", headrot.x, headrot.y, headrot.z));
	ConsoleText(0.1,0.21,Sprintf("wand pos: %.2f, %.2f, %.2f : %i", wandpos.x, wandpos.y, wandpos.z, worldRotation));;
	ConsoleText(0.1,0.24,Sprintf("wand rot: %.2f, %.2f, %.2f", wandrot.x, wandrot.y, wandrot.z));
	ConsoleText(0.1,0.27,Sprintf("wand valuator: %.2f, %.2f", joystick.x, joystick.y));
	ConsoleText(0.1,0.30,Sprintf("buttons: %i, red: %i, yellow: %i, green: %i, blue: %i, joy butt: %i, trigger: %i", buts, b[0], b[1], b[2], b[3], b[4], b[5]));
	#endif
	
	if (b[0]==1 && lastButtons%2==0) 
		joyMode = (joyMode == LOOK ? MOVE : LOOK);
	
	var oldMode = opMode;
	if (b[1]==1 && lastButtons/2%2==0 && b[5] == 0)
		opMode = (opMode + 1) % NUM_MODES;
	
	//if icon changed load new icon
	if(oldMode != opMode) LoadIcon();
	
	if (b[2]==1 && lastButtons/4%2==0 && b[5] == 0) {
		aadd(shapes, Shape());
		curShape = len(shapes) - 1;
	}
	
	//object just released?
	if (b[5]==0 && lastButtons/32%2==1) shapes[curShape].pauseCount = 20;
		
	ConsoleText(0,0.90,Sprintf("%s | %s", joyMode == LOOK ? "look" : "move", opMode == TRANSLATE_MODE ? "translate" : (opMode == SCALE_MODE ? "scale" : "object")));	
	lastButtons = buts;
	
	//camera translation
	#ifdef CAVE
	var adjU = (joystick.x + 1) / 2;
	var adjR = (joystick.y + 1) / 2;
	#else
	var adjU = 0.5;
	var adjR = 0.5;
	if(j.enabled) {
		adjU = j.x;
		adjR = 1 - j.y;
	}
	#endif
	var dX = (adjU - 0.5 < -DEADZONE || adjU - 0.5 > DEADZONE) ? adjU - 0.5 : 0;
	var dY = (adjR - 0.5 < -DEADZONE || adjR - 0.5 > DEADZONE) ? adjR - 0.5 : 0;
	
	

	if(joyMode == LOOK) {
		//camera rotation
		worldRotation += dX*ROT_SENSITIVITY;
	} else {
		CameraPos += VectorRotate(wandrot.y-worldRotation,0,1,0,CameraGetXAxis(),true) * dX * MV_SENSITIVITY 
					+ VectorRotate(wandrot.y-worldRotation,0,1,0,CameraGetZAxis(),true) * -dY * MV_SENSITIVITY;
		CameraPos.y = 1.1;
		CameraSetPosition(CameraPos);
	}
	
	startVert = CameraPos + headpos + VectorRotate(-worldRotation, 0, 1, 0, wandpos - headpos, false);
	smallShape.pos = CameraPos + wandpos; //headpos + VectorRotate(-worldRotation, 0, 1, 0, wandpos - headpos, false) + [0,0.1,0];
	smallShape.rot = wandrot;
	//smallShape.rot.y -= worldRotation;
	//smallShape.rot.x -= worldRotation;
	
	static var PrecSphereX = 0, PrecSphereY = 0;
	var TR_SENSITIVITY = 0.01;
	//translate
	mSelect.preVisible = mSelect.visible;
	mSelect.visible = false;
	if(b[5]==1 && curShape > -1 && opMode < NUM_MODES) {
		var dX = WandRot.x - PrecSphereX;
		var dY = WandRot.y - PrecSphereY;			

		if(opMode == TRANSLATE_MODE) {
			//OutputLn(Sprintf("WandRot.x: %i",WandRot.x));
			var dVec = shapes[curShape].pos - (CameraPos + headpos); //vector from user head to shape
			dVec = VectorRotate (-worldRotation, 0,1,0, dVec, false);
			dVec = VectorRotate (dY, 0,1,0, dVec, false);
			dVec = VectorRotate (dX, 1,0,0, dVec, false);
			dVec = VectorRotate (worldRotation, 0,1,0, dVec, false);
			shapes[curShape].pos = (CameraPos + headpos) + dVec;
		} else if (opMode == SCALE_MODE) {		
			shapes[curShape].bounds *= dX / 10 + 1;
			shapes[curShape].FloorBounds();
		} else if (opMode == ROTATE_MODE) {
			shapes[curShape].rot.y += dY;
		} else if (b[5]==1 && opMode == TEXTURE_MODE && curShape > -1) {
			//OutputLN("mesh Select");
			mSelect.visible = true;
			mSelect.rot = -wandRot.y / 180 * PI;
		}
		if(curShape > -1) shapes[curShape].CheckBounds();
	}
	PrecSphereX = wandRot.x;
	PrecSphereY = wandRot.y;
	
	if(opMode == TEXTURE_MODE && curShape > -1) {
		if (mSelect.preVisible && !mSelect.Visible) {
			OutputLN(mSelect.selected);
			SetLocalDir("\\shapes\\");
			var pos = shapes[curShape].pos;
			shapes[curShape] = MeshShape(shapes[curShape]);
			shapes[curShape].SetMesh(mSelect.selected, true);
			shapes[curShape].pos = pos;
		}
	}
}
function LoadIcon() {
	SetLocalDir();
	var iconMesh;
	switch(opMode) {
		case TRANSLATE_MODE:
			iconMesh = CVmNewMesh("icons\\translate.aam");
			break;
		case ROTATE_MODE:
			iconMesh = CVmNewMesh("icons\\rotate.aam");
			break;
		case TEXTURE_MODE:
			iconMesh = CVmNewMesh("icons\\object.aam");
			break;
		case SCALE_MODE:
			iconMesh = CVmNewMesh("icons\\scale.aam");
			break;
	}
	iconMesh.Normalize(0.05);
    iconObj.LinkToMesh(iconMesh);
    TumpleIcon();
}
function TumpleIcon() {
	iconTumpleAxis = [Rand(1),Rand(1),Rand(1)];
}
function getNewKeyboardEvents()
{
	var key = keyboard();
	var inputScale = 1;
	var scale = [1,1,1];
	
	if(key == "z") scale = [0.9,0.9,0.9];
	else if(key == "x") scale = [1.1,1.1,1.1];
	
	var CameraPos = CameraGetPosition();
	#ifdef SHAPEDEBUG
	if(key == "w") shapes[curShape].pos.y += 0.1;
	else if(key == "s") shapes[curShape].pos.y -= 0.1;
	
	if(key == "d") shapes[curShape].pos.x += 0.1;
	else if(key == "a") shapes[curShape].pos.x -= 0.1;
	#else
	if(key == "w") CameraPos -= VectorRotate(wandrot.y-worldRotation,0,1,0,CameraGetZAxis(),true) * 0.1;
	else if(key == "s") CameraPos += VectorRotate(wandrot.y-worldRotation,0,1,0,CameraGetZAxis(),true) * 0.1;
		
	if(key == "d") CameraPos += VectorRotate(wandrot.y-worldRotation,0,1,0,CameraGetXAxis(),true) * 0.1;
	else if(key == "a") CameraPos -= VectorRotate(wandrot.y-worldRotation,0,1,0,CameraGetXAxis(),true) * 0.1;
	#endif
	
	CameraSetPosition(CameraPos);
	
	if(key == "r") shapes[curShape].pos.z -= 0.1;
	else if(key == "f") shapes[curShape].pos.z += 0.1;
	
	if(key == "t") wandRot.y -= 10;
	else if(key == "y") wandRot.y += 10;
	
	if(key == "g") wandRot.x -= 10;
	else if(key == "h") wandRot.x += 10;
	
	if(key == "u") wandRot.z -= 10;
	else if(key == "i") wandRot.z += 10;
	
	if(key == "0") kb[0] = (kb[0] == 0 ? 1 : 0);
	if(key == "1") kb[1] = (kb[1] == 0 ? 1 : 0);
	if(key == "2") kb[2] = (kb[2] == 0 ? 1 : 0);
	if(key == "3") kb[3] = (kb[3] == 0 ? 1 : 0);
	if(key == "4") kb[4] = (kb[4] == 0 ? 1 : 0);
	if(key == "5") kb[5] = (kb[5] == 0 ? 1 : 0);
	
	if (key == "<") worldRotation -= 5;
	else if (key == ">") worldRotation += 5;
	
	//ConsoleText(0.05, 0.15, Sprintf("bounds: %.2f %.2f %.2f",shapes[curShape].bounds.x,shapes[curShape].bounds.y,shapes[curShape].bounds.z));
	//ConsoleText(0.05, 0.12, Sprintf("position: %.2f %.2f %.2f",shapes[curShape].pos.x,shapes[curShape].pos.y,shapes[curShape].pos.z));
	//ConsoleText(0.05, 0.09, Sprintf("bot, top: %.2f %.2f",shapes[curShape].corners[0].y,shapes[curShape].corners[2].y));
	
	if(key == "n")  {
		aadd(shapes, Shape());
		curShape = len(shapes) - 1;
	}
	if(key == "m")  {
		curShape++;
		curShape %= len(shapes);
	}
	if(key == "b")
		shapes[curShape].ResetShape();
}

function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);
			
			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}
