/* Include s3d symbols */
#include <Script3d.h>
#include <Camera.s3d.h>

/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000;


// TODO: put your global variables here


/* Camera globals */
var CamPos = [0.0, 1.8, 30.0]; 	// camera position
var shapes;
var curShape = 0;
var MAXBOUND = 50;
var dP = 0.000001;
var scaling = false;

/* Function declarations */
function CameraMoveMouse();
function getNewKeyboardEvents();
function DrawGrid(col, size);

class Shape 
{
	var faces;
	var pos;
	var bounds;
	var corners;
	
	ResetShape();
	SetShape();
	SetShapeFromValues(lt,rt,btm,top,fnt,bk);
	DrawShape();
	CalcBounds(scale);
	CheckBounds();
	CheckValues( bound, lt, olt, ort, bt, tp, obt, otp, ft, bk, oft, obk );
	
	GetLeft();
	GetRight();
	GetTop();
	GetBottom();
	GetFront();
	GetBack();
	
	SetLeft(lt);
	SetRight(rt);
	SetBottom(bt);
	setTop(tp);
	SetFront(ft);
	SetBack(bk);
};
function Shape::Shape()
{
	faces = {  /* Vertex indices for the 6 faces of a cube. */
	  {0, 1, 2, 3}, {3, 2, 6, 7}, {7, 6, 5, 4},
	  {4, 5, 1, 0}, {5, 6, 2, 1}, {7, 4, 0, 3} };
	 
	pos = [0,1,0];
	bounds = [1,1,1];
	corners = Array(8);
	
	for(var i = 0; i < 8; i++)
		corners[i] = Vector(3);
	
	ResetShape();
}
function Shape::ResetShape()
{
	bounds = [1,1,1];
	SetShape();
}
function Shape::SetShape() {
	SetShapeFromValues(-bounds.x,bounds.x,-bounds.y,bounds.y,-bounds.z,bounds.z);
}
function Shape::SetShapeFromValues(lt,rt,btm,top,fnt,bk) 
{
	//left face
	corners[0].x = corners[1].x = corners[2].x = corners[3].x = lt;
	
	//right face
	corners[4].x = corners[5].x = corners[6].x = corners[7].x = rt;
	
	//bottom
	corners[0].y = corners[1].y = corners[4].y = corners[5].y = btm;
	
	//top
	corners[2].y = corners[3].y = corners[6].y = corners[7].y = top;
	
	//back - left or right handedness??
	corners[0].z = corners[3].z = corners[4].z = corners[7].z = fnt;
	
	//front
	corners[1].z = corners[2].z = corners[5].z = corners[6].z = bk;
}

function Shape::DrawShape()
{
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	glDisable(GL_LIGHTING);
	//glLoadIdentity();
	
	glPushMatrix();
	glTranslate(pos);
	glBegin(GL_QUADS);
	for(var i = 0; i < 6; i++)
	{
		glVertex(corners[faces[i][0]]);
		glVertex(corners[faces[i][1]]);
		glVertex(corners[faces[i][2]]);
		glVertex(corners[faces[i][3]]);
	}
	glEnd();
	
	glPopMatrix();
	glPopAttrib();	
}

function Shape::CalcBounds(scale) {
	bounds.x = bounds.x * scale.x;
	bounds.y = bounds.y * scale.y;
	bounds.z = bounds.z * scale.z; 
	
	//bounds.x = bounds.x > MAXBOUND ? MAXBOUND : bounds.x;
	//bounds.y = bounds.y > MAXBOUND / 2 ? MAXBOUND / 2: bounds.y;
	//bounds.z = bounds.z > MAXBOUND ? MAXBOUND : bounds.z;
	
	SetShape();
}
function Shape::CheckBounds() {

	//ground plane
	//if(GetBottom() < 0)  pos.y -= pos.y - bounds.y; 
	
	var leftBound = -MAXBOUND;
	var bottomBound = 0;
	var frontBound = -MAXBOUND;
	
	var rightBound = MAXBOUND;
	var topBound = MAXBOUND;
	var backBound = MAXBOUND;

	// 'jiggle it a little' - removes some edge cases
	pos.x += dP;
	pos.y += dP;
	pos.z += dP;
	
	foreach(var s in shapes) {
		if(s.GetRight() > leftBound)
			leftBound = CheckValues( leftBound, GetLeft(), s.GetLeft(), s.GetRight(), GetBottom() + 0.15, GetTop() - 0.15, 
								s.GetBottom(), s.GetTop(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetLeft() < rightBound)
			rightBound = -CheckValues( -rightBound, -GetRight(), -s.GetRight(), -s.GetLeft(), GetBottom() + 0.15, GetTop() - 0.15,
								s.GetBottom(), s.GetTop(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetTop() > bottomBound)
			bottomBound = CheckValues( bottomBound, GetBottom(), s.GetBottom(), s.GetTop(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetBottom() < topBound)
			topBound = -CheckValues( -topBound, -GetTop(), -s.GetTop(), -s.GetBottom(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetFront() + 0.15, GetBack() - 0.15, s.GetFront(), s.GetBack());
		if(s.GetFront() > frontBound)
			frontBound = CheckValues( frontBound, GetFront(), s.GetFront(), s.GetBack(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetBottom() + 0.15, GetTop() - 0.15, s.GetBottom(), s.GetTop());
		if(s.GetBack() < backBound)
			backBound = -CheckValues( -backBound, -GetBack(), -s.GetBack(), -s.GetFront(), GetLeft() + 0.15, GetRight() - 0.15, 
								s.GetLeft(), s.GetRight(), GetBottom() + 0.15, GetTop() - 0.15, s.GetBottom(), s.GetTop());					
	}	
	
	// jiggle it back
	pos.x -= dP;
	pos.y -= dP;
	pos.z -= dP;
	
	if(GetLeft() < leftBound && GetRight() > rightBound) {
		bounds.x = (rightBound - leftBound) / 2;
		SetShape();
	} else if(GetLeft() < leftBound) SetLeft(leftBound);
	else if(GetRight() > rightBound) SetRight(rightBound);
	
	
	if(GetBottom() < bottomBound && GetTop() > topBound) {
		bounds.y = (topBound - bottomBound) / 2;
		SetShape();
	} else if(GetBottom() < bottomBound) SetBottom(bottomBound);
	else if(GetTop() > topBound) SetTop(topBound);
	
	if(GetFront() < frontBound && GetBack() > backBound) {
		bounds.z = (backBound - frontBound - 0.15) / 2;
		SetShape();
	} else if(GetFront() < frontBound) SetFront(frontBound);
	else if(GetBack() > backBound) SetBack(backBound);
}
function Shape::CheckValues( bound, lt, olt, ort, bt, tp, obt, otp, ft, bk, oft, obk )
{
	if(	//check if the left face is inside other cube
		olt < lt && ort > lt
		//check if the cubes overlap in the vertical direction: 3 cases
		//bottom of this between top and bottom of other
		&& ((otp > bt && obt < bt)
		//top of this between top and bottom of other
		|| (otp > tp && obt < tp)
		//top and bottom of other inside this
		|| (otp < tp && obt > bt))
		//the same 3 cases for front and back
		&& ((oft < ft && obk > ft) || (oft < bk && obk > bk) || (obk < bk && oft > ft))) 	
			bound = ort;

	return bound;
}
function Shape::SetLeft(lt) {
	pos.x = lt + bounds.x;
}
function Shape::SetRight(rt) {
	pos.x = rt - bounds.x;
}
function Shape::SetBottom(bt) {
	pos.y = bt + bounds.y;
}
function Shape::SetTop(tp) {
	pos.y = tp - bounds.y;
}
function Shape::SetFront(bt) {
	pos.z = bt + bounds.z;
}
function Shape::SetBack(tp) {
	pos.z = tp - bounds.z;
}
function Shape::GetLeft() {
	return pos.x - bounds.x;
}
function Shape::GetRight() {
	return pos.x + bounds.x;
}
function Shape::GetBottom() {
	return pos.y - bounds.y;
}
function Shape::GetTop() {
	return pos.y + bounds.y;
}
function Shape::GetFront() {
	return pos.z - bounds.z;
}
function Shape::GetBack() {
	return pos.z + bounds.z;
}
function OnDownload()
{
	// TODO: download your resources here
	// E.g.: FileDownload("resource.ext");
}



function OnInit(params)
{
	/* initialize camera */
	CameraGetCurrent().SetPosition(CamPos);
	
	shapes = Array(2);
	
	shapes[0] = Shape();
	shapes[0].pos = [0,1,2.5];
	shapes[1] = Shape();
	shapes[1].pos = [0,1,0];
}


function OnFrame()
{
	/* manage camera */
	CameraMoveMouse();

	SetClearColor(0,0,0);
	SceneBegin();
	
	DrawGrid([0.5, 0.5, 0.5], 100);
	
	for (var i = 0; i < len(shapes); i++) {
		if(curShape == i) glColor(.26,.71,.90);
		shapes[i].DrawShape();
		if(curShape == i) glColor(1,1,1);
	}
	
	SceneEnd();
}


function DownloadReady(RequestID)
{
	// TODO
}



function OnTimer()
{
	getNewKeyboardEvents();
}



function OnExit()
{
	// TODO: put your cleanup code here
}



// Camera manager (using mouse)
function CameraMoveMouse()
{
	static var InMouseR = false, InMouseL = false, InMouseM = false;				
	static var PrecX = 0, PrecY = 0;			
	// Change these values to modify the mouse sensitivity
	var TR_SENSITIVITY  = 0.001 ;//* SceneScale;
	var ROT_SENSITIVITY = 0.01;
	var SCALE_SENSITIVITY = 0.01;
	var TRANS_SENSITIVITY = 0.1;
	var SCALE_DEADZONE = 0.001;
	// Mouse manager
	if(Mouse.ButtonM && !Mouse.ButtonR)
	{
		if(InMouseM) {
			var dX = Mouse.X - PrecX;
			var d = 1 + (PrecY - Mouse.Y) * SCALE_SENSITIVITY;
			
			ConsoleText(0.05, 0.18, Sprintf("mouse scale: %.4f",d));
		 	shapes[curShape].bounds.x *= d;
		 	shapes[curShape].bounds.y *= d;
		 	shapes[curShape].bounds.z *= d;
			shapes[curShape].CheckBounds();
		}
		PrecX = Mouse.X;
		PrecY = Mouse.Y;
		InMouseL = false;
		InMouseR = false;
		InMouseM = true;	
	}
	else if(Mouse.ButtonM && Mouse.ButtonR) {
		if(InMouseM && InMouseR) {
			var dX = (Mouse.X - PrecX) * TRANS_SENSITIVITY;
			var dY = (PrecY - Mouse.Y) * TRANS_SENSITIVITY;
			
			var dir = Norm(shapes[curShape].pos - camPos) ^ [0,1,0];
			
			ConsoleText(0.05, 0.18, Sprintf("dx: %.4f,dy: %.4f,dir: [%.2f,%.2f,%.2f]",dX,dY,dir.x,dir.y,dir.z));
		 	shapes[curShape].pos.y += dY;
		 	shapes[curShape].pos.x += dX * dir.x;
		 	shapes[curShape].pos.z += dX * dir.z;
			shapes[curShape].CheckBounds();
		}
		PrecX = Mouse.X;
		PrecY = Mouse.Y;
		InMouseL = false;
		InMouseR = true;
		InMouseM = true;
	}
	else if(Mouse.ButtonL && !Mouse.ButtonR)
	{
		//====  Left Button: Camera rotation  ====//
		if (InMouseL)
		{			
			CameraRotate(( Mouse.X-PrecX)*ROT_SENSITIVITY,0,1,0);
			CameraRotateABS((Mouse.Y-PrecY)*ROT_SENSITIVITY,1,0,0);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseL = true;
		InMouseR = false;
		InMouseM = false;
	}
	else
	if(Mouse.ButtonR)
	{
	
		//====  Right Button: Camera translation  ====//
		if (InMouseR)
		{
			var CameraMatrix = CameraGetMatrix();
			var CameraPos = CameraGetPosition();
			if (!Mouse.ButtonL) 
			//====  Translation on X and Z axis ====//
				CameraPos += CameraGetZAxis() * (Mouse.y-PrecY)*TR_SENSITIVITY + CameraGetXAxis() * (Mouse.X- PrecX)*TR_SENSITIVITY;
			else
			//====  Right + Left Button: Translation on Y axis ====//
				CameraPos -= CameraGetYAxis() * (Mouse.y-PrecY)*TR_SENSITIVITY;

			CameraSetPosition(CameraPos);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseR = true;
		InMouseL = false;
		InMouseM = false;
	}	
	else
	{
		InMouseR = false;
		InMouseL = false;
		InMouseM = false;
	}
	/*
	var CameraPos = CameraGetPosition();
	var CameraDir = CameraGetDirection();*/
}

function getNewKeyboardEvents()
{
	var key = keyboard();
	var inputScale = 1;
	var scale = [1,1,1];
	
	if(key == "z") scale = [0.9,0.9,0.9];
	else if(key == "x") scale = [1.1,1.1,1.1];
	
	if(key == "w") shapes[curShape].pos.y += 0.1;
	else if(key == "s") shapes[curShape].pos.y -= 0.1;
		
	if(key == "d") shapes[curShape].pos.x += 0.1;
	else if(key == "a") shapes[curShape].pos.x -= 0.1;
	
	if(key == "r") shapes[curShape].pos.z -= 0.1;
	else if(key == "f") shapes[curShape].pos.z += 0.1;
	
	
	shapes[curShape].CalcBounds(scale);
	shapes[curShape].CheckBounds();
	
	ConsoleText(0.05, 0.15, Sprintf("bounds: %.2f %.2f %.2f",shapes[curShape].bounds.x,shapes[curShape].bounds.y,shapes[curShape].bounds.z));
	ConsoleText(0.05, 0.12, Sprintf("position: %.2f %.2f %.2f",shapes[curShape].pos.x,shapes[curShape].pos.y,shapes[curShape].pos.z));
	ConsoleText(0.05, 0.09, Sprintf("bot, top: %.2f %.2f",shapes[curShape].corners[0].y,shapes[curShape].corners[2].y));
	
	if(key == "n")  {
		aadd(shapes, Shape());
		curShape = len(shapes) - 1;
	}
	if(key == "m")  {
		curShape++;
		curShape %= len(shapes);
	}
	if(key == "b")
		shapes[curShape].ResetShape();
}

function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);
			
			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}
